---
layout: post
title:  "コレクションフレームワーク"
date:   2019-05-06 23:47:45 +0900
categories: [Java, Japanese]
image: 1.png, 2.png, 3.png, 4.png, 5.png, 6.png, 7.png
---


**1.1 コレクションフレームワーク(collections framework)とは?**     

- コレクション
  - 数々の客体(データ)を集めておいたことを意味    

- フレームワーク(framework)
  - 標準化,定型化された体系的なプログラミング方式    

- コレクションフレームワーク(collection framework)
  - コレクションを扱う(保存,削除,検索,比較,整列など)ための標準化されたプログラミング方式
  - コレクションを簡単かつ便利に扱うことができる多様なクラスを提供
  - java.utilパッケージに含む。JDK1.2から提供    

- コレクションクラス(collection class)
  - 多数のデータを保存できるクラス(例, Vector, ArrayList, HashSet)     

**1.2 コレクションフレームワークの核心インタフェース**    

- List
  - 手順があるデータの集合。データの重複を許容する(待機者リスト等)
  - 具現クラス:ArrayList,LinkedList,Stack,Vectorなど      

- Set
  - 手順を維持しないデータの集合,データの重複を許さない。
  - 具現クラス:HashSet,TreeSetなど      

- Map
  - 鍵()と値()の双()()からなるデータの集合手順は維持されず,鍵は重複を許容せず,値は重複を許容する(郵便番号,地域番号等)
  - 具現クラス:HashMap,TreeMap,Hashtable,Propertiesなど     

**1.3 コレクションフレームワークの核心インタフェース**      

- boolean add(Object o),boolean addAll(Collection c)
  -指定されたオブジェクト(o)またはCollection(c)のオブジェクトをコレクションに追加する。    

- boolean contains(Objecto),boolean containsAll(Collection c)
  -指定されたオブジェクト(o)またはCollection(c)のオブジェクトがCollectionに含まれているかを確認する。    

- Iterator iterator
  - CollectionのIteratorを得て返却する。     

- boolean remove(Objecto),boolean removeAll(Collectionc),boolean retainAll(Collectionc)
  - 指定されたCollectionに含まれるオブジェクトだけを残し,他のオブジェクトはCollectionから削除する。 この作業によってCollectionに変化があればtrueを,さもなければfalseを返却する。       

**1.4 Listインタフェースのメソッド–手順O、重複O**        

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/1.png "Screenshot broadcast")               

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/2.png "Screenshot broadcast")               


**1.5 Setインタフェースの–順序X、重複X**           

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/3.png "Screenshot broadcast")            

**1.6 Mapインタフェースのメソッド–順序X、重複(鍵X、値段O)**        

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/4.png "Screenshot broadcast")         


**2.1 VectorとArrayList**        

- ArrayListは,既存のVectorを改善したもので,実装原理と機能的に同一,Vectorは自体的に同期化処理されているが,ArrayListはそうではない。      

- Listインタフェースを実装するので,保存手順が維持され,重複を許容する。    

- データの保存空間で配列を使用する(配列基盤)      

```java
public class Vector extends AbstractList
	implements List, RandomAccess, Cloneable, java.io.Serializable
{
	Protected Object [] elementData;//客体を盛るための配列
}
```

**2.2 ArrayListの例題**      

```java
package ch11;

import java.util.ArrayList;

public class ArrayListEx1 {
	public static void main  {
		ArrayList list=new ArrayList(10);//基本長さが10、オブジェクト配列
		list.add("111");//boolean add(Object obj);
		list.add("222");
		list.add("333");
		list.add("222");
		list.add(333);//list.add(new Integer(333));

		System.out.println(list);//[111、222、333、222、333]

		list.add(0、"000");
		System.out.println(list);//[000、111、222、333、222、333]

		システム.out.println("index="+ list。indexOf("333"));//index=3

		list.remove("333");
		System.out.println(list);//[000、111、222、222、333]

		System.out.println(list.remove("333"));//false削除されないなぜなら、4番は数タイプだからだ。
		System.out.println("index=" + list.indexOf("333"));

		for(int i=0; i<list.size(); i++) // index=-1
			list.set(i, i+"");

		System.out.print("{");
		for(int i=0; i<list.size(); i++) {
			if (i == list.size()-1)
				System.out.print(list.get(i));
			else
				System.out.print(list.get(i)+", ");			
		}
		System.out.println("}"); // {0, 1, 2, 3, 4}

//		for(int i=0; i<list.size(); i++)
//			list.remove(i); // [1, 3]

		for(int i=list.size(); i>=0; i--)
			System.out.println(list); // []
	}
}
```      


**2.3 ArrayListに保存されたオブジェクトの削除過程**       

- ArrayListに保存された三番目のデータ(data[2])を削除する過程。 list.remove(2);を呼び出し     

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/5.png "Screenshot broadcast")      

  - (1). 削除するデータの下のデータを一間ずつ上にコピーして削除するデータを被る     
```java
  System.arraycopy(data、3、data、2、2) // data[3]でdata[2]で2つのデータをコピーしという意味だ
```

  - (2). データが全て一間ずつ移動したので最後のデータはnullに変更してデータが削除され、データの個数がへったのでsizeの値を減少させる。     
```java
  data[size-1]=null;
```

  -(3). 最後のデータを削除する場合、(1)の過程(配列のコピー)は必要ない。   

**2.4 Vectorの大きさ(size)=保存されたオブジェクトの数と容量(capacity)=配列の長さ**   

```java
//1.容量()が5人Vectorを生成する。
Vector v=new Vector(5);
v.add("1");
v.add("2");
v.add("3");

//2.空いた空間をなくしている。(容量と大きさが同じになる。)
v.trimToSize();

//3.capacityが6以上になるようにする。
v.ensureCapacity(6);

//4.sizeが7としたとされる。
v.setSize(7);

//5.Vectorに保存されたすべての要素を除去する。
v.clear;
```

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/6.png "Screenshot broadcast")    

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/7.png "Screenshot broadcast")     


**2.6 ArrayListの長所と短所**    

- 長所    
- 配列は構造が簡単で,データを読むのにかかる時間(接近時間,access time)が短い。     

- 短所1     
  - サイズを変更しなければならない場合は,新しい配列を生成した後,データをコピーしなければならない。    
  - サイズ変更を避けるために十分に大きい配列を生成すると, メモリが無駄になる。     
- 短所2     
  - 非順次的なデータの追加,削除に時間がかかる     
  - データを追加したり削除したりするために,他のデータを移動しなければならない     
  - しかし,順次データを追加(終わりに追加)と削除(終りから削除)は速い。     

**3.1 LinkedList–、配列の短所を補完**     
- リンクドリスト(linked list) – 連結リスト。データ接近性の悪い      
![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/8.png "Screenshot broadcast")      

  - データの削除: 一度の参照の変更だけで可能           
![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/9.png "Screenshot broadcast")           

  - データの追加: 一度のNode客体の生成と二度の参照変更だけで可能          
![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/10.png "Screenshot broadcast")               

**3.2 LinkedList–二重連結リスト**        
- ダブルリンクドリスト(doubly linked list) – 二重連結リスト,接近性の向上         
![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/11.png "Screenshot broadcast")    

- ダブリサーキュラー·リンクド·リスト(doubly circular linked list) – 二重円形連結リスト
![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/12.png "Screenshot broadcast")      

**3.3 ArrayList vs.LinkedList–性能比較**         
1. 順次データを追加/削除 – ArrayListが速い          
2. 非順次的にデータを追加/削除–LinkedListが速い        
3. 接近時間(access time)–ArrayListが速い          

```java     
package ch11;

import java.util.;

public class ArrayListLinkedListTest {
      public static void main(String args[]) {
            // 追加するデータの個数を考慮して十分に捕まえなければならない。
            ArrayList al=new ArrayList(2000000);
            LinkedList l= new LinkedList();

            System.out.println("=順次的に追加する=");
            System.out.println("ArrayList:"+add1(al)); // ArrayList:210
            System.out.println("LinkedList:"+add1(ll)); // LinkedList:978
            System.out.println();
            System.out.println("=途中で追加する =");
            System.out.println("ArrayList:"+add2(al)); // ArrayList:2529
            System.out.println("LinkedList:"+add2(ll)); // LinkedList:10
            System.out.println();
            System.out.println("=途中で削除する=");
            System.out.println("ArrayList:"+remove2(al)); // ArrayList:2472
            System.out.println("LinkedList:"+remove2(ll)); // LinkedList:146
            System.out.println();
            System.out.println("=非順次的に追加する=");
            System.out.println("ArrayList:"+remove1(al)); // ArrayList:6
            System.out.println("LinkedList:"+remove1(ll)); // LinkedList:28
      }

      public static long add1(List list){
            long start= System.current TimeMillis;
            for(int i=0;i<1000000;i++)list.add(i+"");
            long end= System.current TimeMillis;
            return end - start;
      }

      public static long add2(List list){
            long start= System.current TimeMillis;
            for(int i=0;i<10000;i++)list.add(500、"X");
            long end= System.current TimeMillis;
            return end - start;
      }

      public static long remove1(List list){
            long start= System.current TimeMillis;
            for(int i=list.size()-1;i>=0;i--)list.remove(i);
            long end= System.current TimeMillis;
            return end - start;
      }

      public static long remove2(List list){
            long start= System.current TimeMillis;
            for(int i=0;i<10000;i++)list.remove(i);
            long end= System.current TimeMillis;
            return end - start;
      }
}
```          


-n番目のデータのアドレス=配列のアドレス+(n-1)*データタイプの大きさ           

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/13.png "Screenshot broadcast")     

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/14.png "Screenshot broadcast")     

**4.1スタックとキュー(Stack&Queue)**      
- スタック(): LIFO構造。最後に保存されたものを一番先に取り出す。      
  - 数式計算,数式括弧検査,undo/redo,後ろ/前へ(ウェブブラウザ)      
- キュ(): FIFO構造。最初に保存したものを一番先に取り出す。   
  - 最近の使用文書,印刷作業待機リスト,バッファー     


- Stack        
  - 括弧二つが一致する場合      

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/15.png "Screenshot broadcast")     

  - 括弧二つが一致しない場合
![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/16.png "Screenshot broadcast")     

- Queue         

```java
class QueueEx1 {
	static Queue q= new LinkedList();
	static final int MAX_SIZE=5;	//Queueに最大5個まで保存されるようにする。

	public static void main(String[] args) {
		System.out.println("helpを入力するとヘルプを見ることができます。");
		while(true) {
			System.out.print(">>");
			try {
                             // 画面からライン単位で入力される。
				Scanner s = new Scanner(System.in);  
				String input = s.nextLine().trim();

				if("".equals(input)) continue;

				if(input.equalsIgnoreCase("q")) {
					System.exit(0);
				} else if(input.equalsIgnoreCase("help")) {
					System.out.println(" help - 助言を示します。");
					System.out.println("qまたはQ - プログラムを終了します。");
					System.out.println ("history - 最近入力したコマンドを"+ MAX_SIZE +"個見せてくれます。");
				} else if(input.equalsIgnoreCase("history")) {
					int i=0;
					// 入力されたコマンドを保存して,
					save(input);    

					// LinkedListの内容を見せてくれる。
					LinkedList tmp = (LinkedList)q;
					ListIterator it = tmp.listIterator();

					while(it.hasNext()) {
						System.out.println(++i+"."+it.next());
					}
				} else {
					save(input);    
					System.out.println(input);
				} // if(input.equalsIgnoreCase("q")) {
			} catch(Exception e) {
				System.out.println("入力エラーです");
			}
		// while (true)
	} //  main()

	public static void save(String input) {
		// queueに保存する。
		if(!)""(equals(input))
			q.offer(input);

		// queueの最大サイズを超えると,一番最初に入力されたものを削除する。
		if(q.size) > MAX_SIZE) // size()はCollectionインタフェースに定義
			q.remove();
	}
} // end of class

```

**4.2 Queueの変形–Deque、PriorityQueue、BlockingQueue**       
- デッキ:両端から保存()と削除可能(StackとQueueの結合)(具現クラス:ArrayDeque,LinkedList)           

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/17.png "Screenshot broadcast")         

- 優先順位キュー(PriorityQueue):優先順位が高いことから取り出し(nullの保存は不可能)、入力[3、1、5、2、4]→出力[1、2、3、4、5]           
- ブロークキングキュ(BlockingQue):空いているときに取り出しと,詰まっているときの入れ方を指定された時間の中遅延させる(block)→ マルチスレッド          

- PriorityQueueはヒップ整列を利用して資料を保存し,順序に合わせて自動的に内部配列を出力する。          

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/18.png "Screenshot broadcast")     

**5.1 Enumeration、Iterator、ListIterator**     
- コレクションに保存されたデータにアクセスするのに使われるインターフェース     
- EnumerationはIteratorの旧バージョン     
- ListIteratorはIteratorのアクセスを向上するもの(単方向→両方向)      

- Iterator    
  - boolean hasNext():読み込む要素が残っているか確認する。 あればtrue,いなければfalseを返却する     
  - Object next():次の要素を読んでくるnext()を呼び出す前にhasNext()を呼び出して読み込む要素があるかを確認することが安全である。      

**5.2 Iterator**     
- コレクションに保存された要素を読んでくる方法を標準化したもの       
- コレクションにiterator()を呼び出してIteratorを具現した客体を得て使用      

```java
Collection c= new ArrayList(); // 他のコレクションに変更するときは,この部分だけ修正すればよい。
....
Iterator it= c.iterator;
while(it.hasNext()){
	System.out.println(it.next));
}

Map map= new HashMap();
....
Iterator list=map.entrySet()。iterator;
```         

```java          
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorEx1 {

	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		list.add("1");
		list.add("2");
		list.add("3");
		list.add("4");
		list.add("5");

		Iterator it= list.iterator;///Iteratorは使い捨て

//		while(it.hasNext()) {
//			System.out.println(it.next());
//			it.remove();
//		}

		it.forEachRemaining(System. out::println);
	} // main
}
```        

**5.3 ListIterator–Iteratorの機能を拡張(相続)**          
- Iteratorのアクセスを向上させたのがListIteratorである。 (片方向→両方向)         
- listIterator()を通じて得られる。 (Listを具現したコレクションクラスに存在)         
- boolean hasNext():読み込む次の要素が残っているか確認する。 あればtrue,いなければfalseを返却する       
- boolean hasPrevious():読み込む以前の要素が残っているか確認する。 あればtrue,いなければfalseを返却する   
- Object next():次の要素を読み込んでくる。 next() を呼び出す前に,hasNext() を呼び出して,読み込む要素があるかを確認することが安全である。        
- Object previous():以前の要素を読み上げてくる。 previous()を呼び出す前にhasPrevious()を呼び出して読み込む要素があるかを確認することが安全である。       

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF/19.png "Screenshot broadcast")              

**6.1 Arrays(1/3)–配列を扱う便利なメソッド(static)提供**           
- 1. 配列の出力 – toString()    
```java       
int[] arr = {3,1,5,2,7,9};
System.out.println(Arrays.toString(arr)); // [3, 1, 5, 2, 7, 9]
```        

- 2.多次元配列の比較と出力–deepToString()、equals()、deepEquals()      
```java
System.out.println(Arrays.toString(arr)); [0, 1, 2, 3, 4]
System.out.println(Arrays.deepToString(arr2D)); // [[11, 12], [21, 22]]

String[][] str2D = new String[][]{{“aaa”, “bbb”}, {“AAA”, “BBB”}};
String[][] str2D2 = new String[][]{{“aaa”, “bbb”}, {“AAA”, “BBB”}};

System.out.println(Arrays.equals(str2D, str2D2)); // false
System.out.println(Arrays.deepEquals(str2D, str2D2)); // true
```      

**6.1 Arrays(2/3)–配列を扱う便利なメソッド(static)提供**      
- 3. 配列のコピー – copyOf()、copyOfRange()      

```java
int[] arr = {0,1,2,3,4};
int[] arr2 = Arrays.copyOf(arr, arr.length); // arr2=[0,1,2,3,4]
int[] arr3 = Arrays.copyOf(arr, 3); // arr3=[0,1,2]
int[] arr4 = Arrays.copyOf(arr, 7); // arr4=[0,1,2,3,4,0,0]

int[] arr5 = Arrays.copyOfRange(arr, 2, 4); // arr2=[2,3] 4は含まれないこと
int[] arr6 = Arrays.copyOfRange(arr, 0, 7); // arr2=[0,1,2,3,4,0,0]
```

- 4. 配列を満たすため – fill()、setAll()      

int[] arr = new int[5];
Arrays.fill(arr, 9); // arr=[9,9,9,9,9]
Arrays.setAll(arr,  ()→ (int)(Math.random()*5)+1);


**6.1 Arrays(3/3)–配列を扱う便利なメソッド(static)提供**       
- 5. 配列をListに変換–asList(Object… a)         
```java
List list=Arrays.asList(new Integer[]{1、2、3、4、5});
List list=Arrays.asList(1、2、3、4、5);
list.add(6); //UnsupportedOperationException例外発生

List list=new ArrayList(Arrays.asList(1、2、3、4、5)); // 変更可能なArrayList生成
list.add(6);//No problem!
```       

- 6. 配列の整列と検索–sort()、binarySearch()      
```java
int[]arr={3、2、0、1、4};//整列されていない配列
int idx=Arrays.binarySearch(arr、2);//idx=-5間違った結果

Arrays.sort;//配列arrを整列する。
System.out.println(Arrays.toString(arr));//[0、1、2、3、4]
int idx=Arrays.binarySearch(arr、2); // idx=2正しい結果		

List list=Arrays.asList(1、2、3、4、5);
list.add(6); // 例外発生

List list2=new ArrayList(list);
list2.add(6); // 例外発生しないこと

int[]arr={3、1、5、2、7、9};
System.out.println(Arrays.binarySearch(arr、2)); // 結果-1

Arrays.sort;
System.out.println(Arrays.toString(arr)); // 結果[1、2、3、5、7、9]
System.out.println(Arrays.binarySearch(arr、2)); // 結果1
```
